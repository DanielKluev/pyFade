"""
Test granular export progress tracking functionality.
"""

from unittest.mock import Mock

from py_fade.controllers.export_controller import ExportController
from py_fade.dataset.export_template import ExportTemplate
from py_fade.gui.window_export_wizard import ExportWizard, ExportWorkerThread
from tests.helpers.export_wizard_helpers import create_test_template


def test_export_controller_accepts_progress_callback(app_with_dataset, temp_dataset):
    """
    Test that ExportController accepts and stores progress callback.
    """
    callback = Mock()
    template = ExportTemplate(
        name="Test Template",
        description="Test",
        training_type="SFT",
        output_format="JSONL-ShareGPT",
        facets_json=[],
    )

    controller = ExportController(app_with_dataset, temp_dataset, template, target_model_id="test-model", progress_callback=callback)

    assert controller.progress_callback is callback


def test_export_controller_progress_callback_invoked_sft(app_with_dataset, temp_dataset, tmp_path):
    """
    Test that progress callback is invoked during SFT export with correct parameters.
    """
    # Create test facet and template
    _facet, template = create_test_template(temp_dataset)

    # Create callback to track calls
    callback_calls = []

    def progress_callback(current_facet_idx, total_facets, facet_name, current_sample, total_samples):
        """
        Track progress callback invocations.
        """
        callback_calls.append({
            'current_facet_idx': current_facet_idx,
            'total_facets': total_facets,
            'facet_name': facet_name,
            'current_sample': current_sample,
            'total_samples': total_samples,
        })

    # Create controller with callback
    controller = ExportController(app_with_dataset, temp_dataset, template, target_model_id="mock-echo-model",
                                  progress_callback=progress_callback)

    output_path = tmp_path / "test_export.jsonl"
    controller.set_output_path(output_path)

    # Note: This test may not have actual samples, so callback may not be invoked
    # We're primarily testing that the callback parameter is wired correctly
    try:
        controller.run_export()
    except ValueError:
        # Expected if no samples are available
        pass

    # Verify callback was set up (even if not called due to no samples)
    assert controller.progress_callback is progress_callback


def test_export_worker_thread_progress_callback(qtbot):  # pylint: disable=unused-argument
    """
    Test that ExportWorkerThread's progress callback calculates progress correctly.
    """
    # Create a mock export controller
    mock_controller = Mock(spec=ExportController)
    mock_controller.progress_callback = None

    # Simulate successful export
    def mock_run_export():
        """
        Simulate export with progress callbacks.
        """
        # Simulate progress for 2 facets, 5 samples each
        if mock_controller.progress_callback:
            # Facet 1
            mock_controller.progress_callback(1, 2, "Facet 1", 0, 5)
            mock_controller.progress_callback(1, 2, "Facet 1", 2, 5)
            mock_controller.progress_callback(1, 2, "Facet 1", 5, 5)
            # Facet 2
            mock_controller.progress_callback(2, 2, "Facet 2", 0, 5)
            mock_controller.progress_callback(2, 2, "Facet 2", 3, 5)
            mock_controller.progress_callback(2, 2, "Facet 2", 5, 5)
        return 10

    mock_controller.run_export = mock_run_export

    # Create worker thread
    worker = ExportWorkerThread(mock_controller)

    # Set up signal capturing
    progress_signals = []

    def capture_progress(progress, message):
        """
        Capture progress signals.
        """
        progress_signals.append({'progress': progress, 'message': message})

    worker.progress_updated.connect(capture_progress)

    # Run the worker
    worker.run()
    qtbot.wait(100)

    # Verify progress signals were emitted
    assert len(progress_signals) >= 2  # At least start and completion

    # Check that we got progress updates with facet information
    facet_messages = [sig for sig in progress_signals if 'Facet' in sig['message']]
    assert len(facet_messages) > 0

    # Verify message format includes expected information
    for sig in facet_messages:
        message = sig['message']
        assert 'Facet' in message
        assert 'Sample' in message

    # Check final progress is 100%
    assert progress_signals[-1]['progress'] == 100
    assert 'completed successfully' in progress_signals[-1]['message'].lower()


def test_export_worker_progress_message_format(qtbot):  # pylint: disable=unused-argument
    """
    Test the format of progress messages generated by ExportWorkerThread.
    """
    mock_controller = Mock(spec=ExportController)
    worker = ExportWorkerThread(mock_controller)

    # Test the progress callback directly
    progress_signals = []

    def capture_progress(progress, message):
        """
        Capture progress signals.
        """
        progress_signals.append({'progress': progress, 'message': message})

    worker.progress_updated.connect(capture_progress)

    # Simulate various progress scenarios
    # pylint: disable=protected-access
    worker._progress_callback(1, 3, "First Facet", 0, 10)
    qtbot.wait(50)
    assert len(progress_signals) == 1
    msg = progress_signals[-1]['message']
    assert "Facet 1/3" in msg
    assert "First Facet" in msg
    assert "Sample 0/10" in msg
    assert "2 facets remaining" in msg

    worker._progress_callback(1, 3, "First Facet", 5, 10)
    qtbot.wait(50)
    msg = progress_signals[-1]['message']
    assert "Sample 5/10" in msg

    worker._progress_callback(2, 3, "Second Facet", 0, 20)
    qtbot.wait(50)
    msg = progress_signals[-1]['message']
    assert "Facet 2/3" in msg
    assert "Second Facet" in msg
    assert "1 facet remaining" in msg

    worker._progress_callback(3, 3, "Third Facet", 10, 15)
    qtbot.wait(50)
    msg = progress_signals[-1]['message']
    assert "Facet 3/3" in msg
    assert "Third Facet" in msg
    # No "remaining" message for last facet
    assert "remaining" not in msg
    # pylint: enable=protected-access


def test_export_worker_progress_percentage_calculation(qtbot):  # pylint: disable=unused-argument
    """
    Test that progress percentage is calculated correctly across multiple facets.
    """
    mock_controller = Mock(spec=ExportController)
    worker = ExportWorkerThread(mock_controller)

    progress_values = []

    def capture_progress(progress, message):  # pylint: disable=unused-argument
        """
        Capture progress values.
        """
        progress_values.append(progress)

    worker.progress_updated.connect(capture_progress)

    # Test with 2 facets
    # Facet 1 should contribute 0-50% of total progress
    # pylint: disable=protected-access
    worker._progress_callback(1, 2, "Facet 1", 0, 10)
    qtbot.wait(50)
    first_facet_start = progress_values[-1]
    assert 10 <= first_facet_start < 50  # Should be low but not 0

    worker._progress_callback(1, 2, "Facet 1", 10, 10)  # End of facet 1
    qtbot.wait(50)
    first_facet_end = progress_values[-1]
    assert 40 <= first_facet_end < 60  # Should be around 50%

    # Facet 2 should contribute 50-100% of total progress
    worker._progress_callback(2, 2, "Facet 2", 0, 10)
    qtbot.wait(50)
    second_facet_start = progress_values[-1]
    assert 40 <= second_facet_start < 60  # Should be around 50%

    worker._progress_callback(2, 2, "Facet 2", 5, 10)  # Middle of facet 2
    qtbot.wait(50)
    second_facet_mid = progress_values[-1]
    assert 60 <= second_facet_mid < 85  # Should be around 75%

    worker._progress_callback(2, 2, "Facet 2", 10, 10)  # End of facet 2
    qtbot.wait(50)
    second_facet_end = progress_values[-1]
    assert 90 <= second_facet_end <= 99  # Should be near 100% but capped at 99
    # pylint: enable=protected-access

    # Verify progress is monotonically increasing (allowing for rounding)
    for i in range(1, len(progress_values)):
        assert progress_values[i] >= progress_values[i - 1] - 1  # Allow 1% tolerance for rounding


def test_export_wizard_displays_granular_progress(app_with_dataset, temp_dataset, qtbot, tmp_path):
    """
    Test that ExportWizard displays granular progress information.
    """
    # Create test facet and template
    create_test_template(temp_dataset)

    wizard = ExportWizard(None, app_with_dataset, temp_dataset)
    qtbot.addWidget(wizard)

    # Select template and navigate through wizard
    wizard.show_step(ExportWizard.STEP_TEMPLATE_SELECTION)
    item = wizard.template_list.item(0)
    wizard.template_list.setCurrentItem(item)
    qtbot.wait(100)

    # Navigate to model selection
    wizard.show_step(ExportWizard.STEP_MODEL_SELECTION)
    qtbot.wait(100)

    # Navigate to output selection
    wizard.show_step(ExportWizard.STEP_OUTPUT_SELECTION)
    output_path = tmp_path / "test_export.jsonl"
    wizard.output_path = output_path
    wizard.output_path_input.setText(str(output_path))
    qtbot.wait(100)

    # Test update_progress method directly
    wizard.show_step(ExportWizard.STEP_EXPORT_PROGRESS)
    qtbot.wait(100)

    # Simulate progress updates
    wizard.update_progress(25, "Facet 1/2: Test Facet - Sample 5/10 - (1 facet remaining)")
    qtbot.wait(100)

    assert wizard.progress_bar.value() == 25
    assert "Facet 1/2" in wizard.progress_label.text()
    assert "Sample 5/10" in wizard.progress_label.text()

    wizard.update_progress(75, "Facet 2/2: Test Facet - Sample 8/10")
    qtbot.wait(100)

    assert wizard.progress_bar.value() == 75
    assert "Facet 2/2" in wizard.progress_label.text()
